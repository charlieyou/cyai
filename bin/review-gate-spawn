#!/usr/bin/env bash
# review-gate-spawn - Spawn multi-model reviewers for an artifact
#
# Usage: review-gate-spawn <artifact-path>
#        review-gate-spawn  # Uses session-scoped latest.md if exists
#
# Creates session-scoped gate-state.json and spawns Codex, Gemini reviewers
# in the background. Each writes output to <session>/reviews/<model>.json and
# creates a <session>/reviews/<model>.done sentinel on completion.
#
# Acceptance Criteria Implementation:
# - [AC1] Script accepts artifact path as argument: resolve_artifact() L41-54, main() L195
# - [AC2] Creates session-scoped reviews/ directory: clean_state() L88
# - [AC3] Spawns available reviewers (skip missing CLIs with warning): preflight_check() L32-37, spawn_reviewer() L139-141
# - [AC4] Creates gate-state.json with created_at timestamp: main() L211, L220, L229, L258
# - [AC5] Background processes survive script exit: spawn_reviewer() runs reviewer commands in background subshells
# - [AC6] .done sentinel files created on completion: spawn_reviewer() L149, L156, L163
# - [AC7] Cleans up old state at start: clean_state() L85-89, called from main() L198
# - [AC8] Handles absolute paths via $CLAUDE_PROJECT_DIR or git root: L14

set -euo pipefail

# Resolve helper scripts relative to this file (works when symlinked)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source shared library
source "$SCRIPT_DIR/review-gate-lib.sh"

# --- Session metadata (required for session-scoped paths) ---
OWNER_SESSION_KEY="${REVIEW_GATE_SESSION_KEY:-}"
OWNER_SOURCE="${REVIEW_GATE_SESSION_SOURCE:-}"
OWNER_SESSION_ID="${REVIEW_GATE_SESSION_ID:-}"
OWNER_TRANSCRIPT_PATH="${REVIEW_GATE_TRANSCRIPT_PATH:-}"

# [AC8] Session-scoped path resolution
if [[ -z "$OWNER_SESSION_ID" ]]; then
    echo "Error: REVIEW_GATE_SESSION_ID is required" >&2
    echo "This script should be called from review-gate-check context" >&2
    exit 1
fi

REVIEW_DIR=$(resolve_review_dir "$OWNER_SESSION_ID" "$OWNER_TRANSCRIPT_PATH")
STATE_FILE="$REVIEW_DIR/gate-state.json"
REVIEWS_DIR="$REVIEW_DIR/reviews"

# --- Preflight checks ---
preflight_check() {
    local missing=()
    # Required: jq
    if ! command -v jq >/dev/null; then
        missing+=("jq")
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "Missing required commands: ${missing[*]}" >&2
        exit 1
    fi

    # Optional: codex, gemini (warn if missing, but continue)
    for cmd in codex gemini; do
        if ! command -v "$cmd" >/dev/null; then
            echo "Warning: $cmd not found, will skip this reviewer" >&2
        fi
    done
}

# --- Determine artifact path ---
# [AC1] Determine artifact path from argument or session-scoped latest.md
resolve_artifact() {
    local arg="${1:-}"

    if [[ -n "$arg" && -f "$arg" ]]; then
        # [AC1] Explicit path provided as argument
        realpath "$arg"
    elif [[ -f "$REVIEW_DIR/latest.md" ]]; then
        # Session-scoped artifact
        realpath "$REVIEW_DIR/latest.md"
    else
        echo "No artifact found. Provide path as argument." >&2
        exit 1
    fi
}

# --- Check for active gate ---
check_existing_gate() {
    if [[ -f "$STATE_FILE" ]]; then
        local status
        status=$(jq -r '.status // "unknown"' "$STATE_FILE" 2>/dev/null || echo "unknown")

        if [[ "$status" == "pending" || "$status" == "awaiting_decision" ]]; then
            # Check if it's stale (>30 min old)
            local created_at age_seconds
            created_at=$(jq -r '.created_at // ""' "$STATE_FILE" 2>/dev/null || echo "")
            if [[ -n "$created_at" ]]; then
                local created_epoch now_epoch
                created_epoch=$(date -d "$created_at" +%s 2>/dev/null || echo 0)
                now_epoch=$(date +%s)
                age_seconds=$((now_epoch - created_epoch))

                if [[ $age_seconds -lt 1800 ]]; then
                    echo "Review gate already active (status: $status, age: ${age_seconds}s)" >&2
                    echo "Use review-gate-resolve to complete the existing gate first." >&2
                    exit 1
                fi
                # Stale, proceed to clean up
                echo "Cleaning up stale gate (age: ${age_seconds}s)" >&2
            fi
        fi
    fi
}

# --- Clean previous state ---
clean_state() {
    rm -f "$STATE_FILE"
    rm -rf "$REVIEWS_DIR"
    # [AC2] Creates session-scoped reviews/ directory
    mkdir -p "$REVIEWS_DIR"
}

# --- Compute SHA256 of artifact ---
compute_sha256() {
    local file="$1"
    if command -v sha256sum >/dev/null 2>&1; then
        sha256sum "$file" | cut -d' ' -f1
        return 0
    fi

    if command -v shasum >/dev/null 2>&1; then
        shasum -a 256 "$file" | cut -d' ' -f1
        return 0
    fi

    echo "Error: sha256sum or shasum is required" >&2
    exit 1
}

# --- Build review prompt ---
build_prompt() {
    local artifact_path="$1"
    local content
    content=$(cat "$artifact_path")

    cat <<PROMPT
You are reviewing an artifact for quality and correctness.

## Artifact
Path: $artifact_path

\`\`\`
$content
\`\`\`

## Evaluation Criteria
1. Completeness - Are all necessary aspects covered?
2. Accuracy - Are claims grounded in evidence?
3. Actionability - Are next steps clear and concrete?
4. Consistency - Any contradictions?
5. Scope - Appropriately scoped?

## Output Format
JSON only, no markdown code fences:
{
  "verdict": "PASS" | "FAIL" | "NEEDS_WORK",
  "confidence": 0.0-1.0,
  "issues": ["..."],
  "summary": "1-2 sentences"
}
PROMPT
}

# --- Spawn a reviewer ---
# [AC3, AC5, AC6] Spawn a reviewer with warning if CLI missing
# Returns 0 on success (reviewer spawned), 1 on failure (CLI not found)
# Completion is tracked via .done sentinel files, not PIDs
# Sentinel is only created if the reviewer CLI exits successfully
# A .failed marker is created on non-zero exit to prevent stalling
spawn_reviewer() {
    local name="$1"
    local cmd="$2"
    local prompt_file="$3"
    local schema_file="$4"

    # Ensure reviews directory exists
    mkdir -p "$REVIEWS_DIR"

    local output_file="$REVIEWS_DIR/${name}.json"
    local sentinel_file="$REVIEWS_DIR/${name}.done"
    local failed_file="$REVIEWS_DIR/${name}.failed"

    # [AC3] Skip missing CLIs with warning
    if ! command -v "$cmd" >/dev/null; then
        echo "Skipping $name: $cmd not found" >&2
        return 1
    fi

    case "$name" in
        gemini)
            REVIEW_OUT="$output_file" \
            REVIEW_DONE="$sentinel_file" \
            REVIEW_FAIL="$failed_file" \
            REVIEW_PROMPT="$prompt_file" \
            nohup setsid bash -c '
                if gemini -o json < "$REVIEW_PROMPT" > "$REVIEW_OUT" 2>&1; then
                    touch "$REVIEW_DONE"
                else
                    touch "$REVIEW_FAIL"
                fi
            ' >/dev/null 2>&1 &
            ;;
        codex)
            REVIEW_OUT="$output_file" \
            REVIEW_DONE="$sentinel_file" \
            REVIEW_FAIL="$failed_file" \
            REVIEW_PROMPT="$prompt_file" \
            REVIEW_SCHEMA="$schema_file" \
            nohup setsid bash -c '
                if codex exec -m gpt-5.2-codex -s read-only --output-schema "$REVIEW_SCHEMA" - < "$REVIEW_PROMPT" > "$REVIEW_OUT" 2>&1; then
                    touch "$REVIEW_DONE"
                else
                    touch "$REVIEW_FAIL"
                fi
            ' >/dev/null 2>&1 &
            ;;
        *)
            echo "Unknown reviewer: $name" >&2
            return 1
            ;;
    esac

    return 0
}

# --- Determine trigger source ---
determine_source() {
    local artifact_path="$1"
    local basename
    basename=$(basename "$artifact_path")

    case "$basename" in
        healthcheck*) echo "healthcheck" ;;
        architecture*) echo "architecture-review" ;;
        breakdown*) echo "bd-breakdown" ;;
        latest.md) echo "auto" ;;
        *) echo "manual" ;;
    esac
}

# --- Main ---
main() {
    preflight_check

    local artifact_path
    artifact_path=$(resolve_artifact "${1:-}")

    check_existing_gate
    # [AC7] Clean up old state at start
    clean_state

    local artifact_sha256
    artifact_sha256=$(compute_sha256 "$artifact_path")

    local trigger_source
    trigger_source=$(determine_source "$artifact_path")

    local prompt_file="$REVIEWS_DIR/review.prompt"
    build_prompt "$artifact_path" > "$prompt_file"

    # Create JSON schema for structured output
    local schema_file="$REVIEWS_DIR/review-schema.json"
    cat > "$schema_file" <<'SCHEMA'
{
  "type": "object",
  "properties": {
    "verdict": {
      "type": "string",
      "enum": ["PASS", "FAIL", "NEEDS_WORK"]
    },
    "confidence": {
      "type": "number",
      "minimum": 0,
      "maximum": 1
    },
    "issues": {
      "type": "array",
      "items": {"type": "string"}
    },
    "summary": {
      "type": "string"
    }
  },
  "required": ["verdict", "confidence", "issues", "summary"],
  "additionalProperties": false
}
SCHEMA

    # Initialize state
    local now
    now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # [AC4] Create gate-state.json with status tracking and created_at timestamp
    # Note: Completion is tracked via .done sentinel files, not PIDs
    local state_json
    state_json=$(jq -n \
        --arg version "1" \
        --arg status "pending" \
        --arg source "$trigger_source" \
        --arg path "$artifact_path" \
        --arg sha256 "$artifact_sha256" \
        --arg created "$now" \
        --arg owner_key "$OWNER_SESSION_KEY" \
        --arg owner_source "$OWNER_SOURCE" \
        --arg owner_session_id "$OWNER_SESSION_ID" \
        --arg owner_transcript "$OWNER_TRANSCRIPT_PATH" \
        '{
            version: ($version | tonumber),
            status: $status,
            trigger_source: $source,
            artifact: {path: $path, sha256: $sha256},
            owner: (
                {}
                | (if $owner_key != "" then .session_key = $owner_key else . end)
                | (if $owner_source != "" then .source = $owner_source else . end)
                | (if $owner_session_id != "" then .session_id = $owner_session_id else . end)
                | (if $owner_transcript != "" then .transcript_path = $owner_transcript else . end)
                | if length == 0 then null else . end
            ),
            reviewers: {},
            consensus: null,
            decision: null,
            created_at: $created
        }')

    # Spawn reviewers and record in state
# Completion tracked via .done sentinels (check for <session>/reviews/<name>.done)
    local reviewers_json='{}'
    local spawned=0

    for reviewer in gemini codex; do
        if spawn_reviewer "$reviewer" "$reviewer" "$prompt_file" "$schema_file"; then
            reviewers_json=$(echo "$reviewers_json" | jq \
                --arg name "$reviewer" \
                --arg output "$REVIEWS_DIR/${reviewer}.json" \
                --arg sentinel "$REVIEWS_DIR/${reviewer}.done" \
                '.[$name] = {output_file: $output, sentinel_file: $sentinel, completed_at: null, result: null}')
            spawned=$((spawned + 1))
            echo "Spawned $reviewer" >&2
        fi
    done

    if [[ $spawned -eq 0 ]]; then
        # No reviewers available; resolve gate to avoid blocking stop hooks
        state_json=$(echo "$state_json" | jq \
            --arg status "resolved" \
            --arg verdict "no_reviewers" \
            --arg action "proceed" \
            --arg decided "$now" \
            '.status = $status
             | .consensus = {verdict: $verdict, iteration: 0}
             | .decision = {action: $action, decided_at: $decided, reason: "no_reviewers"}
             | .reviewers = {}')

        echo "$state_json" > "$STATE_FILE"
        echo "No reviewers available; gate resolved as proceed" >&2
        echo "State file: $STATE_FILE" >&2
        exit 0
    fi

    # Update state with reviewers
    state_json=$(echo "$state_json" | jq --argjson reviewers "$reviewers_json" '.reviewers = $reviewers')

    # [AC4] Write gate-state.json file
    echo "$state_json" > "$STATE_FILE"

    echo "Review gate spawned: $spawned reviewers for $artifact_path" >&2
    echo "State file: $STATE_FILE" >&2
}

main "$@"
