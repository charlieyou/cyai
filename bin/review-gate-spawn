#!/usr/bin/env bash
# review-gate-spawn - Spawn multi-model reviewers for an artifact
#
# Usage: review-gate-spawn <artifact-path>
#        review-gate-spawn  # Uses .review/latest.md if exists
#
# Creates .review/gate-state.json and spawns Claude, Codex, Gemini reviewers
# in the background. Each writes output to .review/reviews/<model>.json and
# creates a .review/reviews/<model>.done sentinel on completion.

set -euo pipefail

# Resolve project root via git or env
PROJECT_ROOT="${CLAUDE_PROJECT_DIR:-$(git rev-parse --show-toplevel 2>/dev/null || pwd)}"
REVIEW_DIR="$PROJECT_ROOT/.review"
STATE_FILE="$REVIEW_DIR/gate-state.json"
REVIEWS_DIR="$REVIEW_DIR/reviews"

# --- Preflight checks ---
preflight_check() {
    local missing=()
    # Required: jq and claude
    for cmd in jq claude; do
        command -v "$cmd" >/dev/null || missing+=("$cmd")
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "Missing required commands: ${missing[*]}" >&2
        exit 1
    fi

    # Optional: codex and gemini (warn if missing, but continue)
    for cmd in codex gemini; do
        if ! command -v "$cmd" >/dev/null; then
            echo "Warning: $cmd not found, will skip this reviewer" >&2
        fi
    done
}

# --- Determine artifact path ---
resolve_artifact() {
    local arg="${1:-}"

    if [[ -n "$arg" && -f "$arg" ]]; then
        # Explicit path provided
        realpath "$arg"
    elif [[ -f "$REVIEW_DIR/latest.md" ]]; then
        # Default to latest.md
        realpath "$REVIEW_DIR/latest.md"
    else
        echo "No artifact found. Provide path or create .review/latest.md" >&2
        exit 1
    fi
}

# --- Check for active gate ---
check_existing_gate() {
    if [[ -f "$STATE_FILE" ]]; then
        local status
        status=$(jq -r '.status // "unknown"' "$STATE_FILE" 2>/dev/null || echo "unknown")

        if [[ "$status" == "pending" || "$status" == "awaiting_decision" ]]; then
            # Check if it's stale (>30 min old)
            local created_at age_seconds
            created_at=$(jq -r '.created_at // ""' "$STATE_FILE" 2>/dev/null || echo "")
            if [[ -n "$created_at" ]]; then
                local created_epoch now_epoch
                created_epoch=$(date -d "$created_at" +%s 2>/dev/null || echo 0)
                now_epoch=$(date +%s)
                age_seconds=$((now_epoch - created_epoch))

                if [[ $age_seconds -lt 1800 ]]; then
                    echo "Review gate already active (status: $status, age: ${age_seconds}s)" >&2
                    echo "Use review-gate-resolve to complete the existing gate first." >&2
                    exit 1
                fi
                # Stale, proceed to clean up
                echo "Cleaning up stale gate (age: ${age_seconds}s)" >&2
            fi
        fi
    fi
}

# --- Clean previous state ---
clean_state() {
    rm -f "$STATE_FILE"
    rm -rf "$REVIEWS_DIR"
    mkdir -p "$REVIEWS_DIR"
}

# --- Compute SHA256 of artifact ---
compute_sha256() {
    local file="$1"
    sha256sum "$file" | cut -d' ' -f1
}

# --- Build review prompt ---
build_prompt() {
    local artifact_path="$1"
    local content
    content=$(cat "$artifact_path")

    cat <<PROMPT
You are reviewing an artifact for quality and correctness.

## Artifact
Path: $artifact_path

\`\`\`
$content
\`\`\`

## Evaluation Criteria
1. Completeness - Are all necessary aspects covered?
2. Accuracy - Are claims grounded in evidence?
3. Actionability - Are next steps clear and concrete?
4. Consistency - Any contradictions?
5. Scope - Appropriately scoped?

## Output Format
JSON only, no markdown code fences:
{
  "verdict": "PASS" | "FAIL" | "NEEDS_WORK",
  "confidence": 0.0-1.0,
  "issues": ["..."],
  "summary": "1-2 sentences"
}
PROMPT
}

# --- Spawn a reviewer ---
spawn_reviewer() {
    local name="$1"
    local cmd="$2"
    local prompt="$3"
    local output_file="$REVIEWS_DIR/${name}.json"
    local sentinel_file="$REVIEWS_DIR/${name}.done"

    if ! command -v "$cmd" >/dev/null; then
        echo "Skipping $name: $cmd not found" >&2
        return 1
    fi

    case "$name" in
        claude)
            # Claude: use --allowedTools "" for read-only
            (
                nohup setsid claude -p --allowedTools "" "$prompt" > "$output_file" 2>&1
                touch "$sentinel_file"
            ) &
            ;;
        codex)
            # Codex: use -s read-only for sandbox mode
            (
                nohup setsid codex exec -s read-only "$prompt" > "$output_file" 2>&1
                touch "$sentinel_file"
            ) &
            ;;
        gemini)
            # Gemini: -s for stdin prompt
            (
                echo "$prompt" | nohup setsid gemini -s > "$output_file" 2>&1
                touch "$sentinel_file"
            ) &
            ;;
        *)
            echo "Unknown reviewer: $name" >&2
            return 1
            ;;
    esac

    echo $!
}

# --- Determine trigger source ---
determine_source() {
    local artifact_path="$1"
    local basename
    basename=$(basename "$artifact_path")

    case "$basename" in
        healthcheck*) echo "healthcheck" ;;
        architecture*) echo "architecture-review" ;;
        breakdown*) echo "bd-breakdown" ;;
        latest.md) echo "auto" ;;
        *) echo "manual" ;;
    esac
}

# --- Main ---
main() {
    preflight_check

    local artifact_path
    artifact_path=$(resolve_artifact "${1:-}")

    check_existing_gate
    clean_state

    local artifact_sha256
    artifact_sha256=$(compute_sha256 "$artifact_path")

    local trigger_source
    trigger_source=$(determine_source "$artifact_path")

    local prompt
    prompt=$(build_prompt "$artifact_path")

    # Initialize state
    local now
    now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    local state_json
    state_json=$(jq -n \
        --arg version "1" \
        --arg status "pending" \
        --arg source "$trigger_source" \
        --arg path "$artifact_path" \
        --arg sha256 "$artifact_sha256" \
        --arg created "$now" \
        '{
            version: ($version | tonumber),
            status: $status,
            trigger_source: $source,
            artifact: {path: $path, sha256: $sha256},
            reviewers: {},
            consensus: null,
            decision: null,
            created_at: $created
        }')

    # Spawn reviewers and record in state
    local reviewers_json='{}'
    local spawned=0

    for reviewer in claude codex gemini; do
        local pid
        if pid=$(spawn_reviewer "$reviewer" "$reviewer" "$prompt"); then
            reviewers_json=$(echo "$reviewers_json" | jq \
                --arg name "$reviewer" \
                --arg pid "$pid" \
                --arg output "$REVIEWS_DIR/${reviewer}.json" \
                '.[$name] = {pid: ($pid | tonumber), output_file: $output, completed_at: null, result: null}')
            spawned=$((spawned + 1))
            echo "Spawned $reviewer (PID: $pid)" >&2
        fi
    done

    if [[ $spawned -eq 0 ]]; then
        echo "No reviewers could be spawned" >&2
        exit 1
    fi

    # Update state with reviewers
    state_json=$(echo "$state_json" | jq --argjson reviewers "$reviewers_json" '.reviewers = $reviewers')

    # Write state file
    echo "$state_json" > "$STATE_FILE"

    echo "Review gate spawned: $spawned reviewers for $artifact_path" >&2
    echo "State file: $STATE_FILE" >&2
}

main "$@"
